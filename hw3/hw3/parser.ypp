%{
    #include <iostream>
    #include "attributes.hpp"
    #include "output.hpp"
    #include "semantic.hpp"
    using namespace std;
    
    extern int yylex();
    extern int yylineno;
    extern char* yytexr;
    void yyerror(const char*);
    Table table;
    
    
    %}
/* Type tokens */
%token VOID // special case: can be a return type, but not a variable declaration
%token INT
%token BYTE
%token B
%token BOOL
/* Binary Arithmetic Operations */
%left PLUS MINUS
%left MULT DIV
/* Logical Operations */
%left AND
%left OR
%left NOT
/* Values */
%token TRUE
%token FALSE
%token NUM
%token STRING
/* Control Flow */
%token IF
%token ELSE
%token WHILE
%token BREAK
%token RETURN
/* Brackets and Parenthesis */
%left LPAREN RPAREN
%left LBRACE RBRACE
%left LBRACK RBRACK
/* Relational Operators */
/* keep them separated inorder to
 give different precedence to every op */
%left BINOP
%left RELOP
/* Assigment */
%right ASSIGN
/* ID */
%token ID
/* Separators */
%token SC
%token COMMA

%%

Program      : Funcs
;
Init         : { rule_init(); }
Funcs        : FuncDecl
             | /*epsilon*/
;
FuncDecl     : RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE
                {
                    //TODO: should check if defined (in the table);
                    String func_name = (Id*)$2->id;
                    TypeId func_ret = (Type*)$1->type;
                    
                    
                    
                }
;
RetType      : Type { $$=$1; }
             | VOID { $$=$1; }
;
Formals      : FormalsList { $$ = $1;}
             | /*epsilon*/ { $$ = new FormList(); /*empty list*/}
;
FormalsList  : FormalDecl { $$ = new FormList()->add((FormDec*)$1->id); }
             | FormalDecl COMMA FormalsList { $$ = rule_FormalsList__FormalDecl_COMMA_FormalList((FormDec*)$1, (FormList*)$3); }
;
FormalDecl   : Type ID { $$ = void rule_FormalDecl__Type_ID((TypeId)$1, (Id*)$2); }
             | Type ID LBRACK NUM RBRACK { $$ = rule_FormalDecl__Type_ID_LBRACK_NUM_RBRACK((TypeId)$1, (Id*)$2, (NumVal*)$4); }
             | Type ID LBRACK NUM B RBRACK { $$ = rule_FormalDecl__Type_ID_LBRACK_NUM_RBRACK((TypeId)$1, (Id*)$2, (NumVal*)$4); }
;
//TODO
Statements   : Statement
             | Statements Statement
;
//TODO
Statement    : LBRACE Statements RBRACE
             | FormalDecl SC { rule_Statement__FormalDecl_SC((FormDec*)$1); }
             | Type ID ASSIGN Exp SC { rule_Statement__Type_ID_ASSIGN_Exp_SC((TypeId)$1, (Id*)$2, (Expr*)$4); }
             | ID ASSIGN Exp SC { rule_Statement__ID_ASSIGN_Exp_SC((Id*)$1, (Expr*)$3); }
             | ID LBRACK Exp RBRACK ASSIGN Exp SC { rule_Statement__ID_LBRACK_Exp_RBRACK_ASSIGN_Exp_SC((Id*)$1, (Expr*)$3, (Expr*)$6); }
             | Call SC
             | RETURN SC { rule_Statement__RETURN_SC(); }
             | RETURN Exp SC { rule_Statement__RETURN_Exp_SC((Expr*)$2); }
             | IF LPAREN Exp RPAREN Statement { rule_Statement__IF_LPAREN_Exp_RPAREN_Statement((Expr*)$3); }
             | IF LPAREN Exp RPAREN StatementWithElse ELSE Statement { rule_Statement__IF_LPAREN_Exp_RPAREN_StatementWithElse_ELSE_Statement((Expr*)$3);}
             | WHILE LPAREN Exp RPAREN Statement { rule_Statement__WHILE_LPAREN_Exp_RPAREN_Statement((Expr*)$3); }
             | BREAK SC { rule_Statement__BREAK_SC(); }
;
//TODO
StatementWithElse : /*epsilon*/
             | IF LPAREN Exp RPAREN StatementWithElse ELSE StatementWithElse
;
//TODO
Call         : ID LPAREN ExpList RPAREN { $$ = void rule_Call__ID_LPAREN_ExpList_RPAREN((Id*)$1, (vector<Expr*>*)$3); }
             | ID LPAREN RPAREN { rule_Call__ID_LPAREN_RPAREN((Id*)$1);
;
//TODO
ExpList      : Exp
             | Exp COMMA ExpList
;
Type         : INT  { $$=$1; }
             | BYTE { $$=$1; }
             | BOOL { $$=$1; }
;
Exp          : LPAREN Exp RPAREN { $$=$1; }
             | ID LBRACK Exp RBRACK { $$ = rule_Exp__ID_LBRACK_Exp_RBRACK((Id*)$1); }
             | Exp BINOP Exp { $$ = rule_Exp__Exp_BINOP_Exp((Expr*)$1, (Expr*)$3); }
             | ID { $$ = new Expr((Id*)$1->type); }
             | Call
             | NUM { $$=$1; }
             | NUM B { $$ = rule_Exp__NUMB((NumVal*)$1->val); }
             | STRING { $$=$1; }
             | TRUE { $$=$1; }
             | FALSE { $$=$1; }
             | NOT Exp { $$ = rule_Exp__NOT_Exp((Expr*)$1); }
             | Exp AND Exp { $$ = rule_Exp__Exp_AND_Exp((Expr*)$1, (Expr*)$3); }
             | Exp OR Exp { $$ = rule_Exp__Exp_OR_Exp((Expr*)$1, (Expr*)$3); }
             | Exp RELOP Exp { $$ = rule_Exp__Exp_RELOP_Exp((Expr*)$1, (Expr*)$3); }
;


%%

void yyerror(const char*) { cout << "syntax error" << endl; }

int main() {
    return yyparse();
}
