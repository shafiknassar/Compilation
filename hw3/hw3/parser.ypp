%{
    #include <iostream>
    #include "attributes.h"
    #include "output.hpp"
    using namespace std;
    
    int yylex();
    void yyerror(const char*);
    %}
/* Type tokens */
%token VOID // special case: can be a return type, but not a variable declaration
%token INT
%token BYTE
%token B
%token BOOL
/* Binary Arithmetic Operations */
%left PLUS MINUS
%left MULT DIV
/* Logical Operations */
%left AND
%left OR
%left NOT
/* Values */
%token TRUE
%token FALSE
%token NUM
%token STRING
/* Control Flow */
%token IF
%token ELSE
%token WHILE
%token BREAK
%token RETURN
/* Brackets and Parenthesis */
%left LPAREN RPAREN
%left LBRACE RBRACE
%left LBRACK RBRACK
/* Relational Operators */
/* keep them separated inorder to
 give different precedence to every op */
%left BINOP
%left RELOP
/* Assigment */
%right ASSIGN
/* ID */
%token ID
/* Separators */
%token SC
%token COMMA

%%

Program      : Funcs
;
Funcs        : FuncDecl
             | /*epsilon*/
;
FuncDecl     : RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE
;
RetType      : Type { $$=$1; }
             | VOID { $$=$1; }
;
Formals      : FormalsList
             | /*epsilon*/
;
FormalsList  : FormalDecl
             | FormalDecl COMMA FormalsList
;
FormalDecl   : Type ID { (Id*)$2->type = (Type*)$1->id; }
             | Type ID LBRACK NUM RBRACK
                {
                    (Id*)$2->type = convertToArrType((Type*)$1->id);
                    if ((Id*)$2->type) {
                        errorMismatch(yylineno);
                        exit(0);
                    }
                }
             | Type ID LBRACK NUM B RBRACK /*TODO*/
;
Statements   : Statement
             | Statements Statement
;
Statement    : LBRACE Statements RBRACE
             | FormalDecl SC
             | Type ID ASSIGN Exp SC
             | ID ASSIGN Exp SC
             | ID LBRACK Exp RBRACK ASSIGN Exp SC
             | Call SC
             | RETURN SC
             | RETURN Exp SC
             | IF LPAREN Exp RPAREN Statement
             | IF LPAREN Exp RPAREN Statement ELSE Statement
             | WHILE LPAREN Exp RPAREN Statement
             | BREAK SC
;
Call         : ID LPAREN ExpList RPAREN
             | ID LPAREN RPAREN
;
ExpList      : Exp
             | Exp COMMA ExpList
;
Type         : INT  { $$=$1; }
             | BYTE { $$=$1; }
             | BOOL { $$=$1; }
;
Exp          : LPAREN Exp RPAREN { $$=$1; }
             | ID LBRACK Exp RBRACK
                {
                    TypeId type = convertFromArrType((Id*)$1->type);
                    if (type == ERROR)
                    {
                        errorMismatch(yylineno);
                        exit(0);
                    }
                    $$ = new Expr(type);
                }
             | Exp BINOP Exp
             | ID { $$ = new Expr((Id*)$1->type); }
             | Call
             | NUM { $$=$1; }
             | NUM B { $$=$1; }
             | STRING { $$=$1; }
             | TRUE { $$=$1; }
             | FALSE { $$=$1; }
             | NOT Exp
                {
                    if ((Exp*)$1->type != BOOL)
                    {
                        errorMismatch(yylineno);
                        exit(0);
                    }
                    $$=$1;
                }
             | Exp AND Exp
                {
                    if ((Exp*)$1->type != BOOL ||
                            (Exp*)$3->type != BOOL)
                    {
                        errorMismatch(yylineno);
                        exit(0);
                    }
                    $$ = new Expr(BOOL);
                }
             | Exp OR Exp
                 {
                     if ((Exp*)$1->type != BOOL ||
                            (Exp*)$3->type != BOOL)
                     {
                         errorMismatch(yylineno);
                         exit(0);
                     }
                     $$ = new Expr(BOOL);
                 }
             | Exp RELOP Exp
                 {
                     if (((Exp*)$3->type != BYTE && (Exp*)$3->type != INT) ||
                            ((Exp*)$1->type != BYTE && (Exp*)$1->type != INT))
                     {
                         errorMismatch(yylineno);
                         exit(0);
                     }
                     $$ = new Expr(BOOL);
                 }
;


%%

void yyerror(const char*) { cout << "syntax error" << endl; }

int main() {
    return yyparse();
}
