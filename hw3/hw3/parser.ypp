%{
    #include <iostream>
    #include "attributes.hpp"
    #include "output.hpp"
    #include "semantic.hpp"
    using namespace std;
    
    
    %}
/* Type tokens */
%token VOID // special case: can be a return type, but not a variable declaration
%token INT
%token BYTE
%token B
%token BOOL
/* Binary Arithmetic Operations */
%left PLUS MINUS
%left MULT DIV
/* Logical Operations */
%left AND
%left OR
%left NOT
/* Values */
%token TRUE
%token FALSE
%token NUM
%token STRING
/* Control Flow */
%token IF
%token ELSE
%token WHILE
%token BREAK
%token RETURN
/* Brackets and Parenthesis */
%left LPAREN RPAREN
%left LBRACE RBRACE
%left LBRACK RBRACK
/* Relational Operators */
/* keep them separated inorder to
 give different precedence to every op */
%left BINOP
%left RELOP
/* Assigment */
%right ASSIGN
/* ID */
%token ID
/* Separators */
%token SC
%token COMMA

%%

Program      : Funcs
;
Init         : {
                    vector<TypeId> arg;
                    arg.push_back(STRING);
                    tableStack.push_back();
                    tableStack[0].insertFunc("print", VOID, arg);
                    arg.pop_back();
                    arg.push_back(INT);
                    tableStack[0].insertFunc("printi", VOID, arg);
                }
Funcs        : FuncDecl
             | /*epsilon*/
;
FuncDecl     : RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE
                {
                    //TODO: should check if defined (in the table);
                    String func_name = (Id*)$2->id;
                    TypeId func_ret = (Type*)$1->type;
                    
                    
                    
                }
;
RetType      : Type { $$=$1; }
             | VOID { $$=$1; }
;
Formals      : FormalsList { $$ = $1;}
             | /*epsilon*/ { $$ = new FormList(); /*empty list*/}
;
FormalsList  : FormalDecl
                {
                    $$ = new FormList()->add((FormDec*)$1->id);
                }
             | FormalDecl COMMA FormalsList
                {
                    FormList decl_list = (FormList*)$3;
                    Id decl_id = (Id*)$1;
                    if(decl_list->redefined(decl_id->id)) {
                        errorDef(yylineno, decl_id->id);
                        exit(0);
                    }
                    decl_list->add(decl_id);
                    $$ = $3;
                }
;
FormalDecl   : Type ID { $$ = void rule_FormalDecl__Type_ID((TypeId)$1, (Id*)$2); }
             | Type ID LBRACK NUM RBRACK { $$ = rule_FormalDecl__Type_ID_LBRACK_NUM_RBRACK((TypeId)$1, (Id*)$2, (NumVal*)$4); }
             | Type ID LBRACK NUM B RBRACK { $$ = rule_FormalDecl__Type_ID_LBRACK_NUM_RBRACK((TypeId)$1, (Id*)$2, (NumVal*)$4); }
;
//TODO
Statements   : Statement
             | Statements Statement
;
//TODO
Statement    : LBRACE Statements RBRACE
             | FormalDecl SC
             | Type ID ASSIGN Exp SC
                {
                    //TODO: should check if defined (in the table);
                    Id *id = (Id*)$2;
                    id->type = (Type*)$1->id;
                    Expr *exp = (Expr*)$4;
                    if (!TYPES_MATCH(id, exp) &&
                        !(id->type == INT && exp->type == BYTE)) {
                            errorMismatch(yylineno);
                            exit(0);
                        }
                 /* if needed, value of id can be assigned here */
                }
             | ID ASSIGN Exp SC
                {
                    //TODO: should check if defined (in the table);
                    if (!TYPES_MATCH((Id*)$1, (Expr*)$3) &&
                        !BYTE_TO_INT_MATCH((Expr*)$3,(Id*)$1)) {
                            errorMismatch(yylineno);
                            exit(0);
                        }
                 /* if needed, value of id can be assigned here */
                }
             | ID LBRACK Exp RBRACK ASSIGN Exp SC
                {
                    //TODO: should check if defined (in the table);
                    Id *arr = (Id*)$1;
                    if (((Expr*)$3->type != INT && (Expr*)$3->type != BYTE)
                        || !ARR_TYPE_MATCH(arr, (Expr*)$6)){
                            errorMismatch(yylineno);
                            exit(0);
                        }
                 /* if needed, value of id can be assigned here */
                }
             | Call SC
             | RETURN SC
             | RETURN Exp SC
             | IF LPAREN Exp RPAREN Statement
             | IF LPAREN Exp RPAREN StatementWithElse ELSE Statement
             | WHILE LPAREN Exp RPAREN Statement
             | BREAK SC
;
//TODO
StatementWithElse : /*epsilon*/
             | IF LPAREN Exp RPAREN StatementWithElse ELSE StatementWithElse
;
//TODO
Call         : ID LPAREN ExpList RPAREN { $$ = void rule_Call__ID_LPAREN_ExpList_RPAREN((Id*)$1, (vector<Expr*>*)$3); }
             | ID LPAREN RPAREN { rule_Call__ID_LPAREN_RPAREN((Id*)$1);
;
//TODO
ExpList      : Exp
             | Exp COMMA ExpList
;
Type         : INT  { $$=$1; }
             | BYTE { $$=$1; }
             | BOOL { $$=$1; }
;
Exp          : LPAREN Exp RPAREN { $$=$1; }
             | ID LBRACK Exp RBRACK { $$ = rule_Exp__ID_LBRACK_Exp_RBRACK((Id*)$1); }
             | Exp BINOP Exp { $$ = rule_Exp__Exp_BINOP_Exp((Expr*)$1, (Expr*)$3); }
             | ID { $$ = new Expr((Id*)$1->type); }
             | Call
             | NUM { $$=$1; }
             | NUM B { $$ = rule_Exp__NUMB((NumVal*)$1->val); }
             | STRING { $$=$1; }
             | TRUE { $$=$1; }
             | FALSE { $$=$1; }
             | NOT Exp { $$ = rule_Exp__NOT_Exp((Expr*)$1); }
             | Exp AND Exp { $$ = rule_Exp__Exp_AND_Exp((Expr*)$1, (Expr*)$3); }
             | Exp OR Exp { $$ = rule_Exp__Exp_OR_Exp((Expr*)$1, (Expr*)$3); }
             | Exp RELOP Exp { $$ = rule_Exp__Exp_RELOP_Exp((Expr*)$1, (Expr*)$3); }
;


%%

void yyerror(const char*) { cout << "syntax error" << endl; }

int main() {
    return yyparse();
}
