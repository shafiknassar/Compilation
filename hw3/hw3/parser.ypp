%{
    #include <iostream>
    #include "attributes.hpp"
    #include "output.hpp"
    using namespace std;
    
    int yylex();
    void yyerror(const char*);
    %}
/* Type tokens */
%token VOID // special case: can be a return type, but not a variable declaration
%token INT
%token BYTE
%token B
%token BOOL
/* Binary Arithmetic Operations */
%left PLUS MINUS
%left MULT DIV
/* Logical Operations */
%left AND
%left OR
%left NOT
/* Values */
%token TRUE
%token FALSE
%token NUM
%token STRING
/* Control Flow */
%token IF
%token ELSE
%token WHILE
%token BREAK
%token RETURN
/* Brackets and Parenthesis */
%left LPAREN RPAREN
%left LBRACE RBRACE
%left LBRACK RBRACK
/* Relational Operators */
/* keep them separated inorder to
 give different precedence to every op */
%left BINOP
%left RELOP
/* Assigment */
%right ASSIGN
/* ID */
%token ID
/* Separators */
%token SC
%token COMMA

%%

Program      : Funcs
;
Funcs        : FuncDecl
             | /*epsilon*/
;
FuncDecl     : RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE
;
RetType      : Type { $$=$1; }
             | VOID { $$=$1; }
;
Formals      : FormalsList
             | /*epsilon*/
;
FormalsList  : FormalDecl
             | FormalDecl COMMA FormalsList
;
FormalDecl   : Type ID { (Id*)$2->type = (Type*)$1->id;
                        /*$$ = new FormDec((Id*)$2);*/ }
             | Type ID LBRACK NUM RBRACK
                {
                    (Id*)$2->type = convertToArrType((Type*)$1->id);
                    if ((Id*)$2->type) {
                        errorMismatch(yylineno);
                        exit(0);
                    }
                    /*$$ = new FormDec((Id*)$2);*/
                }
             | Type ID LBRACK NUM B RBRACK /*TODO*/
;
Statements   : Statement
             | Statements Statement
;
Statement    : LBRACE Statements RBRACE
             | FormalDecl SC
             | Type ID ASSIGN Exp SC
             {
                 Id *id = (Id*)$2;
                 id->type = (Type*)$1->id;
                 Expr *exp = (Expr*)$4;
                 if (!TYPES_MATCH(id, exp) &&
                        !(id->type == INT && exp->type == BYTE)) {
                     errorMismatch(yylineno);
                     exit(0);
                 }
                 /* if needed, value of id can be assigned here */
             }
             | ID ASSIGN Exp SC
             {
                 if (!TYPES_MATCH((Id*)$1, (Expr*)$3) &&
                        !BYTE_TO_INT_MATCH((Expr*)$3,(Id*)$1)) {
                     errorMismatch(yylineno);
                     exit(0);
                 }
                 /* if needed, value of id can be assigned here */
             }
             | ID LBRACK Exp RBRACK ASSIGN Exp SC
             {
                 Id *arr = (Id*)$1;
                 if (((Expr*)$3->type != INT && (Expr*)$3->type != BYTE)
                        || !ARR_TYPE_MATCH(arr, (Expr*)$6)){
                     errorMismatch(yylineno);
                     exit(0);
                }
                 /* if needed, value of id can be assigned here */
             }
             | Call SC
             | RETURN SC
             | RETURN Exp SC
             | IF LPAREN Exp RPAREN Statement
             | IF LPAREN Exp RPAREN StatementWithElse ELSE Statement
             | WHILE LPAREN Exp RPAREN Statement
             | BREAK SC
;
StatementWithElse : /*epsilon*/
             | IF LPAREN Exp RPAREN StatementWithElse ELSE StatementWithElse
;
;
Call         : ID LPAREN ExpList RPAREN
             { $$ = new Expr(/* the type of the return value */); }
             | ID LPAREN RPAREN
;
ExpList      : Exp
             | Exp COMMA ExpList
;
Type         : INT  { $$=$1; }
             | BYTE { $$=$1; }
             | BOOL { $$=$1; }
;
Exp          : LPAREN Exp RPAREN { $$=$1; }
             | ID LBRACK Exp RBRACK
                {
                    TypeId type = convertFromArrType((Id*)$1->type);
                    if (type == ERROR)
                    {
                        errorMismatch(yylineno);
                        exit(0);
                    }
                    $$ = new Expr(type);
                }
             | Exp BINOP Exp
             {
                 if (!IS_NUM_TYPE((Expr*)$3) || !IS_NUM_TYPE((Expr*)$1))
                 {
                     errorMismatch(yylineno);
                     exit(0);
                 }
                 if ((Expr*)$3->type == INT || (Expr*)$1->type == INT) {
                     $$ = new Expr(INT);
                 } else {
                     $$ = new Expr(BYTE);
                 }
             }
             | ID { $$ = new Expr((Id*)$1->type); }
             | Call
             | NUM { $$=$1; }
             | NUM B
             {
                 if ((NumVal*)$1->val > 255) {
                     errorByteTooLarge(yylineno, (NumVal*)$1->val);
                     exit(0);
                 }
                 $$ = new ByteVal((NumVal*)$1->val);
             }
             | STRING { $$=$1; }
             | TRUE { $$=$1; }
             | FALSE { $$=$1; }
             | NOT Exp
                {
                    if ((Exp*)$1->type != BOOL)
                    {
                        errorMismatch(yylineno);
                        exit(0);
                    }
                    $$=$1;
                }
             | Exp AND Exp
                {
                    if ((Exp*)$1->type != BOOL ||
                            (Exp*)$3->type != BOOL)
                    {
                        errorMismatch(yylineno);
                        exit(0);
                    }
                    $$ = new Expr(BOOL);
                }
             | Exp OR Exp
                 {
                     if ((Exp*)$1->type != BOOL ||
                            (Exp*)$3->type != BOOL)
                     {
                         errorMismatch(yylineno);
                         exit(0);
                     }
                     $$ = new Expr(BOOL);
                 }
             | Exp RELOP Exp
                 {
                     if (!IS_NUM_TYPE((Expr*)$3) || !IS_NUM_TYPE((Expr*)$1))
                     {
                         errorMismatch(yylineno);
                         exit(0);
                     }
                     $$ = new Expr(BOOL);
                 }
;


%%

void yyerror(const char*) { cout << "syntax error" << endl; }

int main() {
    return yyparse();
}
